# 役割

このClaude Codeカスタムコマンドは、`$ARGUMENT`で指定された設計書ファイルを分析し、AIコーディングアシスタントが効率的にシステム実装を進めるための支援を行います。

## 主要な機能

1. **作業工程の策定**
   - 設計書に基づいた作業工程全体のリスト作成
   - 適切なMarkdown見出しを使用した階層構造での整理

2. **指示プロンプトの生成**
   - 各工程に対応する超簡潔かつ核心を突いた指示
   - AIエージェントがタスクを遂行するための必要最低限の情報構造

3. **構造化されたファイル出力**
   - 指定された出力ディレクトリ配下にファイル群を生成
   - 各工程の成果管理と計画変更履歴の追跡

## 特徴

- **TDDサポート**: サーバーサイドのRed-Green-Refactorサイクル全体を1つの工程単位として扱う
- **自律的なAI利用**: AIエージェントが既存コードを探索・理解し、最適実装を判断
- **成果の追跡管理**: 「前工程の成果」セクションで作業結果を明確に連携
- **コード例非含有**: 具体的なコード例や構造例は指示プロンプトに含めない
- **E2Eテストサポート**: フロントエンドはPlaywrightを使用した動作確認を含む

# ゴール

`$ARGUMENT`で指定された設計書ファイルの内容に基づき、以下を実現すること:

## 1. 全体構成の作成
- 開発全体の作業工程リストを作成
- 各工程共通事項（概要）を整理
- 適切なMarkdown見出しを使用して階層化

## 2. 指示プロンプトの生成
- 各作業工程に対応する超簡潔で核心を突いた指示を作成
- AIエージェントが効率的に開発を進められる情報構造を提供
- ユーザーが成果を反映しやすいプレイスホルダーを含む

## 3. 構造化されたファイル出力
- 指定された出力ディレクトリ配下に保存
- 設計書ファイル名に基づくディレクトリ構造
- 工程ごとに独立したファイルとして管理

## 指示プロンプトの原則
- **「詳細な指示」セクション**: 具体的な手順ではなく、ゴールと要件・制約に焦点を当てる
- **記述量**: 各タスクの本質を捉えた簡潔な指示に留める（実装の詳細はAIエージェントが判断）
- **コード例**: 一切含まない（AIエージェントが既存コードを参照して最適実装を判断）

# ファイル出力構造

## 1. 出力ディレクトリの指定
- **出力先ディレクトリ**: `tmp/tasks`
- ※ このパスを直接編集することで、出力先を変更できます

## 2. ディレクトリ構造

### プロジェクトディレクトリ
- `$ARGUMENT`のファイル名（拡張子を除く）を基に作成
- `[出力先ディレクトリ]/[設計書ファイル名]/`

### サブディレクトリ
- **results/**: 各工程の成果ファイル格納用
- **plan-history/**: 計画変更履歴の管理用
- **pending-tasks/**: 保留中タスクの管理用

## 3. 生成されるファイル

### 全体工程リストと共通事項
- `summary.md`に作業工程リストと共通事項を出力

### 個別タスクファイル
- 形式: `task_[工程番号]_[工程概要].md`
- 工程番号: 3桁のゼロパディング（例: 001, 002）
- 工程概要: 英数字とアンダースコアの識別子
- 例: `task_001_product_api_tdd.md`, `task_002_auth_tdd.md`

### ファイル内の参照
- 設計書ファイルパス（`$ARGUMENT`）
- 共通事項ファイル（`summary.md`）への参照
- 独立したClaude Codeセッションでの実行を前提

### 成果ファイル
- 形式: `results/task_[工程番号]_result.md`
- 各工程の作業結果を記録

# 運用上の注意 (このカスタムコマンドの利用者向け)

## 必須事項

1. **設計書の指定**: このコマンドは`$ARGUMENT`に設計書ファイルパスが渡されることを前提としています。
   - 設計書ファイルが存在しない場合はエラーとなります
   - 相対パスまたは絶対パスで指定可能

2. **出力ディレクトリのカスタマイズ**: 出力先を変更したい場合は、このファイルの上部にある「ファイル出力構造」セクションの「出力先ディレクトリ」のパスを直接編集してください。
   - デフォルト: `tmp/tasks`
   - ディレクトリが存在しない場合は自動作成されます

3. **出力ファイルの確認**
   - コマンド実行後、`[出力ディレクトリ]/[設計書ファイル名]/`を確認
   - 生成されたファイル群をチェック

## タスク実行時の注意

4. **共通事項の確認**
   - 各工程開始前に`summary.md`の「各工程共通事項」を確認
   - 技術スタックや規約を理解

5. **前工程の成果ファイルの確認**
   - タスクファイルの「前工程の成果」セクションを確認
   - **新しいClaude Codeセッション開始時に該当ファイルを読み込む**

6. **成果ファイルの生成**
   - 各指示プロンプトの「この工程の成果ファイル生成」セクションに従う
   - **作業完了後は必ず成果ファイルを生成**
   - 次工程で自動的に参照される

7. **工程ごとの実行**
   - 各タスクファイルを新しいClaude Codeセッションで順番に実行
   - セッション開始時に`summary.md`の参照を推奨

8. **技術的課題の解決**
   - 技術的課題に直面した際はContext7を活用
   - 最新のドキュメントや解決方法を参照

9. **新規タスクの下書き作成**（オプション）
   - 開発中に新タスクの必要性を発見した場合
   - `pending-tasks/`ディレクトリに下書き作成
   - 次回のspec2tasks実行時に正式なタスク番号が割り当て

## 計画の更新（再実行時の動作）

**開発途中で計画を調整したい場合は、同じ設計書でspec2tasksコマンドを再実行してください。**

### 再実行時の動作

1. **既存の成果を保護**
   - 完了済みタスク（`results/`に成果ファイルがある）は上書きしない
   - タスクファイルの内容は更新されない（成果を保護）

2. **計画への影響を反映**
   - 成果ファイルの「計画への影響」セクションを読み取り
   - 後続タスクを調整
   - シンプルな記載でOK（YAML形式は任意）
   - 「調整不要」の場合はその旨を記載

3. **新規タスクの処理**
   - 成果ファイルに「新規タスクの追加」が記載されている場合
     - 正式なタスク番号を付けて生成
   - `pending-tasks/`に手動で作成されたタスク案がある場合
     - それらも統合を検討

4. **バージョン更新**
   - summary.mdの計画バージョンを自動更新
   - 更新日時と理由を記録

5. **変更履歴**
   - `plan-history/`に変更内容を記録
   - ファイル名形式: `YYYY-MM-DD_update_NNN.md`

### 使用例

```bash
# 初回実行
/spec2tasks design.md

# タスク実行後、計画を調整したい場合
/spec2tasks design.md  # 同じコマンドを再実行するだけ
```

### pending-tasksディレクトリの活用

開発中に新たなタスクの必要性に気づいた場合：

1. **成果ファイルに記載**
   - 「計画への影響」セクションに新規タスク追加を記載
   - 必須項目: タスク名、理由、挿入位置（どのタスクの後か）

2. **pending-tasksに下書き作成**（オプション）
   - より詳細な仕様が必要な場合
   - `pending-tasks/`に下書きタスクファイルを作成
   - ファイル名例: `task_xxx_new_requirement.md`
   - 正式な番号は spec2tasks 再実行時に自動割り当て

3. **spec2tasks再実行**
   - 次回実行時に正式な番号付きタスクとして生成
   - 既存タスクの番号は自動的に調整される

この機能により、開発中の発見や変更を柔軟に計画に反映できます。

# 前提条件

## Claude Codeの能力

- 指示に基づいたコードの生成・変更
- テキストベースでの対話的な応答
- リポジトリ内の既存コードの探索・理解
- 設計原則に基づいた最適実装の自律的判断
- 具体的な編集箇所の自動特定

## 技術スタック

使用する主要なライブラリ・フレームワーク:
- **フロントエンド**: React
- **サーバーサイド**: Laravel (PHP)
- **E2Eテスト**: Playwright

**注意**: CLAUDE.mdファイルが存在する場合は、そこに記載された技術スタックを優先して使用します。

## テスト方針

- **フロントエンドUIテスト**: 現状のプロジェクト方針により対象外
- **E2Eテスト**: Playwrightを使用した動作確認は積極的に含む
- **TDDの対象**: 主にサーバーサイドの以下要素
  - ロジック層
  - APIエンドポイント
  - サービスクラス
  - モデル

## 技術的課題解決

Context7を使用して最新のライブラリドキュメントやベストプラクティスを参照

# 手順 (このカスタムコマンドの動作)

## 1. 入力ファイルの読み込み

### 1.1 設計書ファイルの読み込み
- `$ARGUMENT`で指定された設計書ファイルを読み込む
- ファイルが存在しない場合はエラーメッセージを表示して終了
- 内容を解析し、実装要件を抽出する

### 1.2 CLAUDE.mdファイルの読み込み
- プロジェクトルートにCLAUDE.mdファイルが存在する場合、内容を読み込む
- ファイルが存在しない場合は、デフォルトの技術スタックを使用
- 以下の情報を抽出:
  - 環境構築情報
  - 開発コマンド
  - 技術スタック
  - 開発規約

### 1.3 既存の成果ファイル確認
- 出力ディレクトリが既に存在する場合、`results/`ディレクトリを確認
- 既存の成果ファイルから「計画への影響」セクションを抽出
- 後続の計画生成に反映する

## 2. 出力ディレクトリの準備

以下のディレクトリ構造を作成:

1. **出力先ディレクトリのパス取得**
   - このファイル内の「ファイル出力構造」セクションで指定されたパスを読み込む

2. **プロジェクトディレクトリの作成**
   - `$ARGUMENT`からファイル名（拡張子を除く）を抽出
   - `[出力先ディレクトリ]/[設計書ファイル名]/`を作成

3. **サブディレクトリの作成**
   - `results/` - 各工程の成果ファイル格納用
   - `plan-history/` - 計画変更履歴の管理用
   - `pending-tasks/` - 保留中タスクの管理用

## 3. 設計情報の読解と全体計画の策定

### 3.1 設計書の分析
- 実装すべき全機能を把握
- 変更点と考慮事項を整理
- 依存関係を明確化

### 3.2 既存情報の統合
- CLAUDE.mdの情報を計画に反映
- 既存の成果ファイルから「計画への影響」を考慮
- `pending-tasks/`ディレクトリ内のファイルを検討

### 3.3 工程分割の決定
- ユニット・工程への分割方法を決定
- **サーバーサイド**: TDDのRed-Green-Refactorサイクル全体を1つの工程とする
- **フロントエンド**: コンポーネント実装とPlaywright動作確認を含む

## 4. 全体工程リストと共通事項の出力

`summary.md`ファイルを生成し、以下を含める:

- 全作業工程の概要リスト（ユニット名、工程名）
- 各工程共通事項
- CLAUDE.mdから抽出した情報（環境構築、開発コマンド、技術スタック、開発規約）
- 既存のsummary.mdがある場合は計画バージョンを更新
- サーバーサイドの工程には「(TDDサイクル)」を明記

## 5. 各工程の指示プロンプト生成

各作業工程に対応する`task_XXX_*.md`ファイルを生成:

### 5.1 生成ルール
- 既に完了したタスク（成果ファイルが存在）は上書きしない
- 未完了または新規タスクのみ生成・更新
- 「計画への影響」で指定された新規タスクには適切な番号を割り当て

### 5.2 指示プロンプトに含める情報構造
1. **設計書ファイルパス** - `$ARGUMENT`の値を明記
2. **共通事項ファイル参照** - `summary.md`への参照
3. **プロジェクト概要と現在のタスク位置**
   - プロジェクト名、全体目標
   - 現在のユニット/機能
   - 全体における位置と短期的ゴール
4. **前工程の成果**
   - 前工程の成果ファイルへのパス
   - 初回工程の場合は初期状態のプレイスホルダー
5. **このタスクのコア要件**
   - 達成すべき最重要ポイントを箇条書きで要約
6. **詳細な指示**
   - ゴール、主要仕様、制約事項に絞り込み
   - フロントエンドの場合はPlaywright動作確認を含む
7. **成果ファイル生成指示**
   - `results/task_[工程番号]_result.md`として出力

## 6. 技術スタックの反映

- CLAUDE.mdから読み込んだ技術スタック情報を最優先で使用
- LaravelとReactのベストプラクティスをキーワードレベルで含める
- コード例は含めない（簡潔さを保つため）
- Context7の活用について適宜言及

## 7. 外部ドキュメント参照の設定

各タスクファイルに以下を明記:
- 設計書ファイルパス（`$ARGUMENT`）
- 共通事項ファイル（`[出力先ディレクトリ]/[設計書ファイル名]/summary.md`）
- すべてのパスはプロジェクトルートからの相対パスとして記載

# 出力形式 (このカスタムコマンドが生成する内容)

## ディレクトリ構造

```
[出力先ディレクトリ]/
└── [設計書ファイル名]/
    ├── summary.md                        # 作業工程全体のリストと共通事項
    ├── task_001_product_api_tdd.md     # 工程1の指示プロンプト
    ├── task_002_auth_tdd.md            # 工程2の指示プロンプト
    ├── task_003_product_list_ui.md     # 工程3の指示プロンプト
    ├── ...                               # 以降、全工程分のファイル
    ├── results/                          # 各工程の成果ファイル
    │   ├── task_001_result.md          # 工程1の成果
    │   ├── task_002_result.md          # 工程2の成果
    │   └── ...                           # 以降、全工程分の成果ファイル
    ├── plan-history/                     # 計画変更履歴
    │   ├── 2025-07-21_initial.md       # 初期計画
    │   └── 2025-07-22_update_001.md    # 更新履歴1
    └── pending-tasks/                    # 保留中タスク（開発中に発見された新規タスク）
        └── task_xxx_new_requirement.md  # 正式な番号付け前の新規タスク案
```

## summary.md の形式例

````markdown
# 作業工程全体のリストと共通事項

設計書: `$ARGUMENT` （プロジェクトルートからの相対パス）
生成日: YYYY-MM-DD
出力ディレクトリ: `[出力先ディレクトリ]/[設計書ファイル名]/` （プロジェクトルートからの相対パス）

**警告**: このファイルは spec2tasks コマンドによって自動生成されます。手動での編集は推奨されません。

## ファイルパス・参照規約

**重要**: このドキュメント内のすべてのファイルパスは、特に明記されていない限り**プロジェクトルートからの相対パス**です。

- **設計書ファイル**: `$ARGUMENT` - プロジェクトルートからの相対パス
- **タスクファイル**: `[出力先ディレクトリ]/[設計書ファイル名]/task_XXX_*.md` - プロジェクトルートからの相対パス
- **成果ファイル**: `[出力先ディレクトリ]/[設計書ファイル名]/results/task_XXX_result.md` - プロジェクトルートからの相対パス
- **作成・変更したファイル**: 成果報告に記載するファイルパスもプロジェクトルートからの相対パスで記載

## 計画のステータス

### 計画バージョン情報
- **現在のバージョン**: v1.0
- **最終更新日**: YYYY-MM-DD
- **更新理由**: 初期計画

### 変更履歴
- **v1.0** (YYYY-MM-DD): 初期計画生成

### タスク完了状態の確認方法

各タスクの完了状態は、`results/`ディレクトリ内の成果ファイルの有無で判断します：

- **完了済みタスク**: `results/task_XXX_result.md`ファイルが存在する
- **未完了タスク**: 成果ファイルが存在しない
- **依存関係の確認**: 各タスクファイル内の「依存関係と前提条件」セクションを参照

例:

```bash
# タスク001が完了しているか確認
ls results/task_001_result.md  # ファイルが存在すれば完了

# 全タスクの完了状況を一覧
ls results/

# 未完了タスクを確認（タスクファイルと成果ファイルを比較）
ls task_*.md | while read task; do
  result="results/${task%.md}_result.md"
  [ ! -f "$result" ] && echo "未完了: $task"
done
```

## 各工程共通事項

### プロジェクト基本情報
- **プロジェクト名**: [設計書から抽出されたプロジェクト名]
- **全体目標**: [設計書から抽出された全体目標]
- **プロジェクト概要**: [設計書から抽出された概要説明]

### 技術スタック
- **フロントエンド**: React 18.x, TypeScript, [その他主要ライブラリ]
- **バックエンド**: Laravel 8.x, PHP 8.x, MySQL 5.7
- **テスト**: PHPUnit (バックエンド), Playwright (E2E動作確認)
- **インフラ**: Docker, [その他環境情報]

### 環境構築・開発コマンド （CLAUDE.mdより）
- **初期セットアップ**: `docker compose exec app ./docker/initial-setup.sh`
- **フロントエンドビルド**: `make docker-build-front`
- **開発サーバー**: `make docker-dev-server T=admin PORT=3000`
- **テスト実行**: `docker compose exec app vendor/bin/phpunit`
- **コード品質**: `docker compose exec app vendor/bin/php-cs-fixer fix`

### 開発規約・設計原則 （CLAUDE.mdより）
- **コーディング規約**: Laravel標準規約、PSR-12準拠
- **ディレクトリ構造**:
  - コントローラ: `app/Http/Controllers/`
  - サービス: `app/Services/`
  - リポジトリ: `app/Repositories/`
  - イベント: `app/Events/`
  - ジョブ: `app/Jobs/`
- **命名規則**: [プロジェクト固有の命名規則について記載]
- **セキュリティ方針**: Laravelの組み込みセキュリティ機能を使用、CSRF保護、サニタイズ処理

### 既存システムとの連携 （CLAUDE.mdおよび設計書より）
- **既存API**: [既存APIの概要とエンドポイント情報]
- **データベース**: [既存テーベル構造の概要]
- **外部サービス**: [連携する外部サービスの情報]
- **マルチテナントアーキテクチャ**: 会社ベースのテナンシー、倉庫ベースの運用

### Context7活用ガイド
- **Laravel関連**: `/laravel/laravel` でフレームワークドキュメント参照
- **React関連**: `/facebook/react` で最新のReactパターン参照
- **Playwright関連**: `/microsoft/playwright` でE2Eテストパターン参照

## 作業工程リスト

### ユニット1: 商品情報取得APIの開発 (Laravel - TDDサイクル)
1.  **工程001**: 商品情報取得API TDDサイクル (Red-Green-Refactor) → `task_001_product_api_tdd.md`

### ユニット2: ユーザー認証機能の実装 (Laravel - TDDサイクル)
2.  **工程002**: ユーザー認証機能 TDDサイクル (Red-Green-Refactor) → `task_002_auth_tdd.md`

### ユニット3: 商品一覧表示コンポーネントの実装 (React + Playwright動作確認)
3.  **工程003**: ProductListコンポーネント実装と動作確認 → `task_003_product_list_ui.md`

(...以下、設計情報に基づく全ユニットと工程のリスト...)

## 工程実行時の注意事項

1.  **各工程は独立したClaude Codeセッションで実行**してください
2.  **工程開始時にこの`summary.md`を参照**し、共通事項を確認してください
3.  **前工程の成果は必ず次工程のファイルに反映**してください
4.  **技術的課題はContext7を積極的に活用**して解決してください
````

## task_XXX_*.md の形式例（サーバーサイドTDD）

`````markdown
# 指示: Laravel「商品情報取得APIの開発」(TDDサイクル)

**設計書ファイル**: `$ARGUMENT`
**共通事項ファイル**: `[出力先ディレクトリ]/[設計書ファイル名]/summary.md` （プロジェクトルートからの相対パス）

> **重要**: このファイルを新しいClaude Codeセッションで実行する前に、必ず同ディレクトリ内の`summary.md`を参照し、プロジェクトの共通事項（技術スタック、開発規約、既存システムとの連携情報など）を確認してください。

## 1. プロジェクト概要と現在のタスク位置

- **プロジェクト名**: [設計書から抽出されたプロジェクト名]
- **全体目標**: [設計書から抽出された全体目標]
- **現在の作業工程**: 商品情報取得APIの開発 (TDDサイクル)
- **工程ID**: 001
- **プロジェクト全体の工程リストにおける現在位置**: 工程1 / 全X工程中
- **前工程**: なし（初回工程）
- **次工程**: task_002_auth_tdd.md（ユーザー認証機能 TDDサイクル）
- **この工程のゴール**: 「商品情報取得API」の機能を、テスト駆動開発（Red-Green-Refactor）のサイクルを通じて実装し、品質を確保する。

## 2. 依存関係と前提条件

### 必須前工程
- **なし**: 初回工程のため、直接的な依存関係なし

### 前提条件
- **データベース**: Productモデルのスキーマ定義が完了していること
- **認証**: 既存のAuthサービスが利用可能であること
- **テスト環境**: PHPUnitが実行可能な環境が整っていること

### このタスクがブロックされる条件
- **データベーススキーマ未完成**: Productテーブルの定義が未完成の場合
- **認証システム障害**: 既存の認証サービスに問題がある場合

## 3. 前工程の成果（このタスクへのインプット）

**前工程の成果ファイル**: なし（初回工程のため）

- **[初期状態に関する前提情報]**
  - (例: 関連するProductモデルのスキーマ定義は完了済み。認証は既存のAuthサービスを利用する、など)

## 4. このタスクのコア要件（サマリー）

- 商品情報取得API (`GET /api/products/{id}`) をTDDサイクルで実装する。
- Red: まず、APIの主要な振る舞いを検証する失敗するPHPUnitテストを作成する。
- Green: 次に、作成したテストをすべてパスする最小限のAPIロジックを実装する。
- Refactor: 最後に、テストをパスした状態を維持しながら、実装コードの品質を向上させる。
- 技術的課題が発生した場合は、Context7で`/laravel/laravel`を参照し、最新のベストプラクティスを確認する。

## 5. 詳細な指示 (TDDサイクル)

あなたはリポジトリ内の既存コードを探索・理解し、この指示と設計原則、そして`summary.md`に記載された共通事項に基づいて最適な実装を自律的に判断できます。具体的な実装手順は示しませんので、あなたの判断と既存コードに基づいて最適なテストと実装を行ってください。

### 4.1 テスト作成 (Red)
- **目的**: これから実装する「商品情報取得API」の振る舞いを定義・検証するための、失敗するPHPUnitテストケースを作成する。
- **主要な検証ポイント**: 正常な商品IDでのデータ取得、存在しない商品IDでの404エラー、不正な形式のIDでのバリデーションエラー、認証失敗時のエラー。レスポンスのHTTPステータスコードと主要なJSON構造。
- **ヒント**: LaravelのHTTPテスト、データベースアサーション、モック、ファクトリを活用。既存Featureテストを参照。必要に応じてContext7で`/laravel/laravel`のテストドキュメントを確認。

### 4.2 機能実装 (Green)
- **目的**: 4.1で作成したテストケースがすべて成功するように、最小限のAPIロジックを実装する。
- **主要な実装要件**: APIエンドポイントのルーティング定義、コントローラメソッドでのリクエスト処理とレスポンス返却、Eloquentモデルを利用したデータ取得、認証処理の組み込み。
- **ヒント**: Laravelの標準的なディレクトリ構成・作法に従う。`summary.md`の開発規約を遵守。Context7でAPI実装のパターンを参照可能。

### 4.3 リファクタリング (Refactor)
- **目的**: 4.2で実装したコードの内部品質（可読性、保守性、パフォーマンス等）を、テストが成功状態を維持したまま改善する。
- **主要なリファクタリング観点**: コードの重複排除、命名の適切性、SOLID原則の適用可能性、コントローラとモデルの責務分離。
- **ヒント**: Laravelのベストプラクティス（サービスクラスの利用検討など）を意識する。Context7で最新のパターンを確認。

## 6. この工程の成果ファイル生成 (作業完了後に必ず実行してください)

このTDDサイクル全体の作業が完了したら、以下の内容を含む成果ファイルを`results/task_001_result.md`として生成してください。このファイルは次の工程で自動的に参照されます。

````markdown
# 工程001: 商品情報取得API TDDサイクル - 成果報告

## 作成・変更したファイル
- [ファイルパス1] （プロジェクトルートからの相対パス）
- [ファイルパス2] （プロジェクトルートからの相対パス）
- ...

## 各ファイルの変更内容
### ファイル: [ファイルパスA]
- 変更内容: [概要を記述]

### ファイル: [ファイルパスB]
- 変更内容: [概要を記述]

## 実装したAPIエンドポイント
- エンドポイント: `GET /api/products/{id}`
- リクエスト形式: [必要に応じて記載]
- レスポンス形式: [JSON構造の概要]
- エラーレスポンス: [エラーケースと対応するステータスコード]

## 技術的決定事項
- [決定事項1]
- [決定事項2]

## 発生した課題と解決策
- 課題: [課題の内容]
  - 解決策: [解決方法]

## Context7参照情報
- ライブラリID: [参照したライブラリ]
- トピック: [参照したトピック]

## 計画への影響と調整提案
### 重要度: 🔴高 / 🟡中 / 🟢低

### 発見事項
- **技術的発見**: [予期せぬ技術的制約や発見]
- **仕様変更の必要性**: [開発中に判明した仕様変更]
- **パフォーマンス課題**: [性能面での課題や改善提案]

### 計画調整の必要性
- **調整タイプ**:
  - [ ] 既存タスクの内容変更
  - [ ] 新規タスクの追加
  - [ ] タスク順序の変更
  - [ ] タスクの削除/統合
  - [ ] ✅ 調整不要

※ 「調整不要」の場合は、以下の「具体的な調整案」「後続タスクへの影響評価」は記入不要です。

### 具体的な調整案
※ 以下は記載例です。自然言語で簡潔に記載しても構いません。

**例1: シンプルな記載**
- task_002にRedis連携を追加する必要がある
- 新規タスク「Redisキャッシュ層実装」をtask_002の後に追加
- task_003は新規タスク完了待ち

**例2: 構造化された記載（複雑な変更の場合）**
```yaml
updates:
  - type: "add_task"
    after: "task_002"
    new_task:
      name: "Redisキャッシュ層実装"
      reason: "認証トークン管理に必須"
```

### 後続タスクへの影響評価
- **直接影響**: [どのタスクに直接影響するか]
- **間接影響**: [連鎖的に影響を受けるタスク]
- **ブロッカー**: [この課題により実行できないタスク]

## 次工程への申し送り事項
- [申し送り事項1]
- [申し送り事項2]
````

**重要**: 上記のテンプレートに従って、実際の作業内容を記載した成果ファイルを生成してください。
`````

## task_XXX_*.md の形式例（フロントエンド実装）

`````markdown
# 指示: React「商品一覧表示コンポーネントの実装」(Playwright動作確認付き)

**設計書ファイル**: `$ARGUMENT` （プロジェクトルートからの相対パス）
**共通事項ファイル**: `[出力先ディレクトリ]/[設計書ファイル名]/summary.md` （プロジェクトルートからの相対パス）

> **重要**: このファイルを新しいClaude Codeセッションで実行する前に、必ず上記の`summary.md`を参照し、プロジェクトの共通事項（技術スタック、開発規約、既存システムとの連携情報など）を確認してください。

## 1. プロジェクト概要と現在のタスク位置

*   **プロジェクト名**: [設計書から抽出されたプロジェクト名]
*   **全体目標**: [設計書から抽出された全体目標]
*   **現在の作業工程**: 商品一覧表示コンポーネントの実装と動作確認
*   **工程ID**: 003
*   **プロジェクト全体の工程リストにおける現在位置**: 工程3 / 全X工程中
*   **前工程**: task_002_auth_tdd.md（ユーザー認証機能 TDDサイクル）
*   **次工程**: task_004_[次工程名].md
*   **この工程のゴール**: ProductListコンポーネントを実装し、Playwrightで動作を確認する。

## 2. 依存関係と前提条件

### 必須前工程
- **task_001**: 商品情報取得API TDD - ✅完了前提
- **task_002**: ユーザー認証機能 TDD - ✅完了前提

### 前提条件
- **APIエンドポイント**: 商品情報取得APIが実装済みであること
- **認証システム**: ユーザー認証機能が実装済みであること
- **開発環境**: React開発環境が整っていること
- **Playwright**: E2Eテスト環境が利用可能であること

### このタスクがブロックされる条件
- **API連携エラー**: 商品情報APIのレスポンス形式が未確定の場合
- **認証トークンエラー**: 認証システムに問題がある場合
- **ビルドエラー**: Reactプロジェクトのビルドが失敗している場合

## 3. 前工程の成果（このタスクへのインプット）

**前工程の成果ファイル**: `[出力先ディレクトリ]/[設計書ファイル名]/results/task_002_result.md` （プロジェクトルートからの相対パス）

> Claude Codeへの指示: 上記のファイルを読み込んで、前工程で実装されたAPI仕様や認証機能の詳細を確認してください。

> **注**: このファイルパスはプロジェクトルートからの相対パスです。

## 4. このタスクのコア要件（サマリー）

- ProductListコンポーネントをReactで実装する。
- APIからデータを取得し、商品一覧を表示する。
- ローディング状態とエラー状態を適切に処理する。
- Playwrightを使用して、実際のブラウザでの動作を確認する。
- 実装上の課題はContext7で`/facebook/react`の最新パターンを参照する。

## 5. 詳細な指示

### 5.1 コンポーネント実装
- **目的**: 商品一覧を表示するProductListコンポーネントを実装する。
- **主要な実装要件**: APIデータ取得、状態管理（ローディング、エラー、データ）、商品リストのレンダリング、レスポンシブデザイン対応。
- **ヒント**: 既存のコンポーネント構造を参照。HooksやContext APIの活用。必要に応じてContext7で`/facebook/react`のベストプラクティスを確認。`summary.md`の開発規約を遵守。

### 5.2 Playwrightによる動作確認
- **目的**: 実装したコンポーネントが実際のブラウザ環境で正しく動作することを確認する。
- **主要な確認ポイント**:
  - ページ読み込み時のローディング表示
  - データ取得成功時の商品一覧表示
  - エラー発生時のエラーメッセージ表示
  - レスポンシブデザインの動作確認（異なる画面サイズ）
- **ヒント**: Playwright APIを使用してブラウザを制御。スクリーンショット取得も活用。Context7で`/microsoft/playwright`の使用方法を参照可能。

## 6. この工程の成果ファイル生成 (作業完了後に必ず実行してください)

この実装と動作確認の作業が完了したら、以下の内容を含む成果ファイルを`[出力先ディレクトリ]/[設計書ファイル名]/results/task_003_result.md`（プロジェクトルートからの相対パス）として生成してください。

````markdown
# 工程003: 商品一覧表示コンポーネントの実装 - 成果報告

## 作成・変更したファイル
- [ファイルパス1] （プロジェクトルートからの相対パス）
- [ファイルパス2] （プロジェクトルートからの相対パス）
- ...

## 実装したコンポーネント
### ProductListコンポーネント
- ファイルパス: [パス]
- Props: [受け取るPropsの一覧]
- 状態管理: [使用したHooksや状態管理パターン]
- 主要機能: [機能の概要]

## APIとの連携
- 使用エンドポイント: [URL]
- データ取得方法: [fetch/axios/その他]
- エラーハンドリング: [実装した処理]

## Playwrightによる動作確認結果
### 確認項目
- [ ] ページ読み込み時のローディング表示
- [ ] データ取得成功時の商品一覧表示
- [ ] エラー発生時のエラーメッセージ表示
- [ ] レスポンシブデザインの動作

### スクリーンショット
- [ファイルパス]: [スクリーンショットの説明]

### 発見した問題
- [問題があれば記載]

## 技術的決定事項
- [決定事項1]
- [決定事項2]

## Context7参照情報
- ライブラリID: [参照したライブラリ]
- トピック: [参照したトピック]

## 計画への影響と調整提案
### 重要度: 🔴高 / 🟡中 / 🟢低

### 発見事項
- **技術的発見**: [予期せぬ技術的制約や発見]
- **仕様変更の必要性**: [開発中に判明した仕様変更]
- **パフォーマンス課題**: [性能面での課題や改善提案]

### 計画調整の必要性
- **調整タイプ**:
  - [ ] 既存タスクの内容変更
  - [ ] 新規タスクの追加
  - [ ] タスク順序の変更
  - [ ] タスクの削除/統合
  - [ ] ✅ 調整不要

※ 「調整不要」の場合は、以下の「具体的な調整案」「後続タスクへの影響評価」は記入不要です。

### 具体的な調整案
※ 以下は記載例です。自然言語で簡潔に記載しても構いません。

**例1: シンプルな記載**
- task_002にRedis連携を追加する必要がある
- 新規タスク「Redisキャッシュ層実装」をtask_002の後に追加
- task_003は新規タスク完了待ち

**例2: 構造化された記載（複雑な変更の場合）**
```yaml
updates:
  - type: "add_task"
    after: "task_002"
    new_task:
      name: "Redisキャッシュ層実装"
      reason: "認証トークン管理に必須"
```

### 後続タスクへの影響評価
- **直接影響**: [どのタスクに直接影響するか]
- **間接影響**: [連鎖的に影響を受けるタスク]
- **ブロッカー**: [この課題により実行できないタスク]

## 次工程への申し送り事項
- [申し送り事項1]
- [申し送り事項2]
````

**重要**: 上記のテンプレートに従って、実際の作業内容を記載した成果ファイルを生成してください。
`````
